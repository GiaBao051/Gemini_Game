<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>2P Maze Client</title>
  <style>
    body { font-family: system-ui, sans-serif; margin: 16px; }
    #row { display: flex; gap: 16px; align-items: flex-start; }
    canvas { border: 1px solid #999; image-rendering: pixelated; }
    .panel { min-width: 320px; }
    .box { border: 1px solid #ddd; padding: 12px; border-radius: 8px; margin-bottom: 12px; }
    .muted { color: #666; font-size: 13px; }
    button { padding: 8px 10px; margin: 6px 6px 0 0; }
    #status { white-space: pre-wrap; font-family: ui-monospace, Consolas, monospace; font-size: 12px; }
  </style>
</head>
<body>
  <h2>2P Maze (Web Client)</h2>
  <div class="muted">Mở 2 tab (hoặc 2 trình duyệt) để chơi 2 người. Dùng WASD hoặc phím mũi tên.</div>

  <div id="row">
    <canvas id="cv" width="620" height="420"></canvas>

    <div class="panel">
      <div class="box">
        <div><b>Kết nối</b></div>
        <div style="margin-top:8px;">
          Name: <input id="name" value="Player" />
          <button id="btnConnect">Connect</button>
          <button id="btnDisconnect">Disconnect</button>
        </div>
        <div class="muted" style="margin-top:8px;">
          WS: <span id="wsUrl"></span>
        </div>
      </div>

      <div class="box">
        <div><b>Trạng thái</b></div>
        <div id="status"></div>
      </div>

      <div class="box" id="qbox" style="display:none;">
        <div><b>Câu hỏi</b></div>
        <div id="qprompt" style="margin-top:8px;"></div>
        <div id="qmeta" class="muted" style="margin-top:6px;"></div>
        <div id="qchoices" style="margin-top:8px;"></div>
      </div>
    </div>
  </div>

<script>
(() => {
  const WS_URL = "ws://127.0.0.1:8080/ws";
  document.getElementById("wsUrl").textContent = WS_URL;

  const cv = document.getElementById("cv");
  const ctx = cv.getContext("2d");

  // Server tiles
  const T_FLOOR = 0, T_WALL = 1, T_QUIZ = 2;

  let ws = null;
  let myId = null;
  let roomId = null;

  let mapW = 0, mapH = 0;
  let grid = null;
  let treasure = null;
  let starts = {};

  let lastState = null;
  let cell = 20; // will adapt to map size

  function setStatus(obj) {
    const el = document.getElementById("status");
    el.textContent = obj;
  }

  function draw() {
    if (!grid) {
      ctx.clearRect(0,0,cv.width,cv.height);
      ctx.fillText("Chưa có map. Hãy Connect.", 20, 30);
      return;
    }

    ctx.clearRect(0,0,cv.width,cv.height);

    // draw tiles
    for (let y=0; y<mapH; y++) {
      for (let x=0; x<mapW; x++) {
        const t = grid[y][x];
        if (t === T_WALL) ctx.fillStyle = "#222";
        else if (t === T_QUIZ) ctx.fillStyle = "#f1c40f";
        else ctx.fillStyle = "#f5f5f5";
        ctx.fillRect(x*cell, y*cell, cell, cell);
      }
    }

    // treasure
    if (treasure) {
      ctx.fillStyle = "#8e44ad";
      ctx.fillRect(treasure[0]*cell+4, treasure[1]*cell+4, cell-8, cell-8);
    }

    // starts
    Object.entries(starts).forEach(([pid, pos]) => {
      ctx.strokeStyle = "#2c3e50";
      ctx.strokeRect(pos[0]*cell+2, pos[1]*cell+2, cell-4, cell-4);
      ctx.font = "10px monospace";
      ctx.fillStyle = "#2c3e50";
      ctx.fillText("S", pos[0]*cell+6, pos[1]*cell+12);
    });

    // players
    if (lastState && lastState.players) {
      Object.entries(lastState.players).forEach(([pid, p]) => {
        const [x,y] = p.pos;
        const isMe = (pid === myId);

        ctx.fillStyle = isMe ? "#1abc9c" : "#e74c3c";
        ctx.beginPath();
        ctx.arc(x*cell + cell/2, y*cell + cell/2, cell/2 - 3, 0, Math.PI*2);
        ctx.fill();

        if (p.has_treasure) {
          ctx.fillStyle = "#8e44ad";
          ctx.fillRect(x*cell + cell/2 - 4, y*cell + cell/2 - 4, 8, 8);
        }

        ctx.font = "10px monospace";
        ctx.fillStyle = "#000";
        ctx.fillText(isMe ? "ME" : "P", x*cell + 3, y*cell + 12);
      });
    }
  }

  function updateCellSize() {
    // Fit map into canvas
    const maxCellW = Math.floor(cv.width / mapW);
    const maxCellH = Math.floor(cv.height / mapH);
    cell = Math.max(10, Math.min(maxCellW, maxCellH));
  }

  function connect() {
    if (ws && ws.readyState === WebSocket.OPEN) return;

    ws = new WebSocket(WS_URL);
    ws.onopen = () => {
      const name = document.getElementById("name").value || "Player";
      ws.send(JSON.stringify({type:"join", name}));
      setStatus("Connected. Waiting for start...\n");
    };

    ws.onmessage = (ev) => {
      const msg = JSON.parse(ev.data);
      if (msg.type === "start") {
        myId = msg.player_id;
        roomId = msg.room_id;

        // map
        mapW = msg.map.w;
        mapH = msg.map.h;
        grid = msg.map.grid;
        treasure = msg.map.treasure;
        starts = msg.map.starts || {};

        updateCellSize();
        lastState = msg.state;

        setStatus(
          `room=${roomId}\nmyId=${myId}\nphase=${lastState?.phase}\n`
          + `treasure=${JSON.stringify(treasure)}\n`
          + `starts=${JSON.stringify(starts)}\n`
        );
        draw();
      }
      else if (msg.type === "state") {
        lastState = msg;
        const ps = msg.players || {};
        const posSummary = Object.fromEntries(Object.entries(ps).map(([k,v]) => [k, v.pos]));
        setStatus(
          `room=${roomId}\nmyId=${myId}\nphase=${msg.phase}\ncarrier=${msg.carrier}\n`
          + `players=${JSON.stringify(posSummary)}\n`
        );
        draw();
      }
      else if (msg.type === "question") {
        showQuestion(msg);
      }
      else if (msg.type === "event") {
        // show briefly in status
        setStatus((document.getElementById("status").textContent || "") + `\nEVENT: ${msg.name} by ${msg.by}\n`);
      }
      else if (msg.type === "end") {
        setStatus((document.getElementById("status").textContent || "") + `\nEND winner=${msg.winner}\n`);
      }
      else if (msg.type === "error") {
        setStatus((document.getElementById("status").textContent || "") + `\nERROR: ${msg.message}\n`);
      }
    };

    ws.onclose = () => {
      setStatus("Disconnected.\n");
      ws = null;
      myId = null;
    };
  }

  function disconnect() {
    if (ws) ws.close();
  }

  function sendDir(d) {
    if (!ws || ws.readyState !== WebSocket.OPEN) return;
    ws.send(JSON.stringify({type:"input", dir:d}));
  }

  function showQuestion(q) {
    const qbox = document.getElementById("qbox");
    const prompt = document.getElementById("qprompt");
    const meta = document.getElementById("qmeta");
    const choices = document.getElementById("qchoices");

    qbox.style.display = "block";
    prompt.textContent = q.prompt || "";
    meta.textContent = q.meta ? `category=${q.meta.category}, difficulty=${q.meta.difficulty}` : "";
    choices.innerHTML = "";

    (q.choices || []).forEach((c, idx) => {
      const btn = document.createElement("button");
      btn.textContent = `${idx}: ${c}`;
      btn.onclick = () => {
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({type:"answer", qid:q.qid, choice: idx}));
        }
        qbox.style.display = "none";
      };
      choices.appendChild(btn);
    });
  }

  // Keybinds
  window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();
    if (k === "w" || e.key === "ArrowUp") sendDir("U");
    else if (k === "s" || e.key === "ArrowDown") sendDir("D");
    else if (k === "a" || e.key === "ArrowLeft") sendDir("L");
    else if (k === "d" || e.key === "ArrowRight") sendDir("R");
  });

  document.getElementById("btnConnect").onclick = connect;
  document.getElementById("btnDisconnect").onclick = disconnect;

  draw();
})();
</script>
</body>
</html>
