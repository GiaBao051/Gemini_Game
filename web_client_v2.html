<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Maze Duel</title>
  <style>
    :root{
      --bg0:#0b1020;
      --bg1:#0e1630;
      --card:rgba(255,255,255,.06);
      --text:#eaf0ff;
      --muted:rgba(234,240,255,.70);
      --good:#23c9a8;
      --bad:#ff4d6d;
      --warn:#ffcc00;
      --accent:#7c5cff;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius: 16px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color:var(--text);
      background: radial-gradient(1200px 700px at 15% 10%, #1a2b6b 0%, transparent 55%),
                  radial-gradient(900px 600px at 80% 20%, #3b1a6b 0%, transparent 50%),
                  linear-gradient(180deg, var(--bg0), var(--bg1));
      min-height:100vh;
    }
    header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 18px 22px;
      position:sticky; top:0;
      background: linear-gradient(180deg, rgba(11,16,32,.92), rgba(11,16,32,.72));
      backdrop-filter: blur(10px);
      border-bottom: 1px solid rgba(255,255,255,.08);
      z-index:10;
    }
    .brand{display:flex; gap:12px; align-items:center;}
    .logo{
      width:38px; height:38px; border-radius:12px;
      background: linear-gradient(135deg, var(--accent), #25d0ff);
      box-shadow: var(--shadow);
      position:relative;
    }
    .logo:after{content:""; position:absolute; inset:9px; border-radius:10px; background: rgba(0,0,0,.25);}
    .title{display:flex; flex-direction:column; line-height:1.1;}
    .title b{font-size:16px; letter-spacing:.3px}
    .title span{font-size:12px; color:var(--muted)}
    .chips{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
    .chip{
      padding:8px 10px;
      border-radius:999px;
      background: rgba(255,255,255,.07);
      border:1px solid rgba(255,255,255,.10);
      font-size:12px;
      color:var(--muted);
      display:flex; gap:8px; align-items:center;
    }
    .dot{width:10px; height:10px; border-radius:50%; background: rgba(255,255,255,.25);}
    .dot.on{ background: var(--good); box-shadow: 0 0 0 5px rgba(35,201,168,.15); }

    main{
      padding: 18px 22px 26px;
      display:grid;
      grid-template-columns: 1.35fr .65fr;
      gap: 16px;
      align-items:start;
    }
    .card{
      background: var(--card);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .card .head{
      padding: 14px 14px 10px;
      display:flex;
      justify-content:space-between;
      align-items:center;
      border-bottom: 1px solid rgba(255,255,255,.08);
      background: rgba(255,255,255,.03);
    }
    .card .head b{font-size:13px; letter-spacing:.2px}
    .card .head small{color:var(--muted)}
    .card .body{ padding: 14px; }

    #stageWrap{ position:relative; }
    canvas{ width:100%; height:auto; display:block; background: rgba(255,255,255,.03); }

    .overlayHud{
      position:absolute; inset: 12px 12px auto auto;
      display:flex; flex-direction:column; gap:10px;
      align-items:flex-end;
      pointer-events:none;
    }
    .mini{
      width: 180px; height: 120px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.25);
      overflow:hidden;
      box-shadow: var(--shadow);
    }
    .legend{
      padding:10px 12px;
      border-radius: 14px;
      background: rgba(0,0,0,.25);
      border: 1px solid rgba(255,255,255,.10);
      color: var(--muted);
      font-size: 12px;
      box-shadow: var(--shadow);
      min-width: 180px;
    }
    .legend .row{display:flex; gap:10px; align-items:center; margin-top:6px}
    .sw{width:12px;height:12px;border-radius:3px; border:1px solid rgba(255,255,255,.2)}
    .sw.wall{background:#131a2f}
    .sw.quiz{background:#ffcc00}
    .sw.treasure{background:var(--accent)}
    .sw.me{background:var(--good)}
    .sw.opp{background:var(--bad)}
    .grid2{display:grid; grid-template-columns: 1fr; gap:12px;}
    .kv{
      display:grid;
      grid-template-columns: 110px 1fr;
      gap:8px;
      font-size:13px;
      color:var(--muted);
      align-items:center;
    }
    .kv b{color:var(--text); font-weight:700}
    .btnrow{display:flex; gap:10px; flex-wrap:wrap}
    button{
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.08);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 12px;
      cursor:pointer;
      font-weight:700;
      letter-spacing:.15px;
      transition: transform .06s ease, background .15s ease;
    }
    button:hover{ background: rgba(255,255,255,.12) }
    button:active{ transform: translateY(1px) }
    button.primary{ background: linear-gradient(135deg, var(--accent), #25d0ff); border: none; }
    button.danger{ background: rgba(255,77,109,.18); border-color: rgba(255,77,109,.35); }
    input{
      width: 100%;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.25);
      color: var(--text);
      outline:none;
    }
    .playersList{display:flex; flex-direction:column; gap:10px;}
    .pitem{
      display:flex; justify-content:space-between; align-items:center;
      padding:10px 12px;
      border-radius: 14px;
      background: rgba(0,0,0,.20);
      border:1px solid rgba(255,255,255,.08);
    }
    .pitem .left{display:flex; gap:10px; align-items:center; min-width:0;}
    .pitem .left .nm{white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:160px;}
    .badge{
      padding: 4px 8px;
      border-radius: 999px;
      font-size: 11px;
      border:1px solid rgba(255,255,255,.12);
      color: var(--muted);
      background: rgba(255,255,255,.06);
      white-space:nowrap;
    }
    .badge.me{ border-color: rgba(35,201,168,.35); color: rgba(35,201,168,.95); }
    .badge.t{ border-color: rgba(124,92,255,.45); color: rgba(180,165,255,.95); }
    .badge.stun{ border-color: rgba(255,204,0,.45); color: rgba(255,204,0,.95); }
    .feed{ max-height: 220px; overflow:auto; padding-right: 6px; }
    .feed .evt{
      padding: 8px 10px;
      border-radius: 12px;
      margin-bottom: 8px;
      background: rgba(255,255,255,.05);
      border: 1px solid rgba(255,255,255,.08);
      font-size: 12px;
      color: var(--muted);
    }

    #toasts{
      position: fixed; right: 18px; bottom: 18px;
      display:flex; flex-direction:column; gap:10px;
      z-index: 50;
    }
    .toast{
      min-width: 260px;
      max-width: 360px;
      padding: 12px 12px;
      border-radius: 14px;
      background: rgba(10,14,28,.92);
      border: 1px solid rgba(255,255,255,.12);
      box-shadow: var(--shadow);
      color: var(--text);
      font-size: 13px;
      backdrop-filter: blur(10px);
      animation: pop .18s ease;
    }
    .toast small{ display:block; color: var(--muted); margin-top: 3px; font-size:12px }
    .toast.good{ border-color: rgba(35,201,168,.35) }
    .toast.bad{ border-color: rgba(255,77,109,.35) }
    .toast.warn{ border-color: rgba(255,204,0,.35) }
    @keyframes pop{ from{ transform: translateY(6px); opacity:0 } to{ transform: translateY(0); opacity:1 } }

    .modal{
      position: fixed; inset:0;
      display:none;
      align-items:center; justify-content:center;
      background: rgba(0,0,0,.55);
      z-index: 60;
      padding: 18px;
    }
    .modal.on{ display:flex; }
    .modal .panel{
      width: min(740px, 96vw);
      border-radius: 18px;
      background: rgba(12,16,32,.96);
      border: 1px solid rgba(255,255,255,.12);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .modal .panel .mhead{
      padding: 14px 16px;
      border-bottom: 1px solid rgba(255,255,255,.08);
      display:flex; justify-content:space-between; align-items:center;
    }
    .modal .panel .mbody{ padding: 16px; }
    .choiceGrid{ display:grid; grid-template-columns: 1fr; gap:10px; margin-top: 12px; }
    .choice{
      padding: 12px 12px;
      border-radius: 14px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.10);
      cursor:pointer;
      transition: background .15s ease, transform .06s ease;
      user-select:none;
    }
    .choice:hover{ background: rgba(255,255,255,.10) }
    .choice:active{ transform: translateY(1px) }

    .kbd{
      font-family: ui-monospace, Consolas, monospace;
      font-size: 12px;
      padding:2px 6px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: var(--muted);
    }
    .bar{
      height: 10px;
      border-radius: 999px;
      background: rgba(255,255,255,.08);
      overflow:hidden;
      margin-top: 12px;
      border:1px solid rgba(255,255,255,.10);
    }
    .bar > div{
      height: 100%;
      width: 100%;
      background: linear-gradient(90deg, var(--good), var(--warn), var(--bad));
      transform-origin: left;
      transform: scaleX(1);
    }

    .winTitle{ font-size: 22px; letter-spacing:.3px; }
    .sub{ color: var(--muted); margin-top: 6px; line-height:1.35; }

    @media (max-width: 980px){
      main{ grid-template-columns: 1fr; }
      .mini{ width: 160px; height: 108px; }
    }
  </style>
</head>
<body>
<header>
  <div class="brand">
    <div class="logo"></div>
    <div class="title">
      <b>Maze Duel</b>
      <span>2 người chơi • Treasure tug-of-war • Obstacles shift over time</span>
    </div>
  </div>
  <div class="chips">
    <div class="chip"><span class="dot" id="connDot"></span><span id="connText">Disconnected</span></div>
    <div class="chip">Phase <b id="phaseText" style="color:var(--text);">—</b></div>
    <div class="chip">Carrier <b id="carrierText" style="color:var(--text);">—</b></div>
    <div class="chip">MapRev <b id="revText" style="color:var(--text);">0</b></div>
  </div>
</header>

<main>
  <section class="card" id="stageWrap">
    <div class="head">
      <b>Bản đồ</b>
      <small>Di chuyển: <span class="kbd">WASD</span> / <span class="kbd">↑↓←→</span></small>
    </div>
    <canvas id="cv" width="980" height="640" tabindex="0"></canvas>

    <div class="overlayHud">
      <canvas class="mini" id="mini" width="180" height="120"></canvas>
      <div class="legend">
        <div><b style="color:var(--text)">Legend</b></div>
        <div class="row"><span class="sw wall"></span><span>Tường</span></div>
        <div class="row"><span class="sw quiz"></span><span>Quiz</span></div>
        <div class="row"><span class="sw treasure"></span><span>Kho báu</span></div>
        <div class="row"><span class="sw me"></span><span>Bạn</span></div>
        <div class="row"><span class="sw opp"></span><span>Đối thủ</span></div>
      </div>
    </div>
  </section>

  <aside class="grid2">
    <div class="card">
      <div class="head"><b>Kết nối</b><small id="wsShow"></small></div>
      <div class="body">
        <div class="kv"><span>Tên</span><b><input id="name" value="Player" /></b></div>
        <div class="btnrow" style="margin-top:12px;">
          <button class="primary" id="btnConnect">Connect</button>
          <button class="danger" id="btnDisconnect">Disconnect</button>
        </div>
        <div style="margin-top:10px; color:var(--muted); font-size:12px;">
          Mở 2 tab để chơi 2 người. Chướng ngại vật thay đổi theo thời gian; ô thay đổi sẽ nhấp nháy.
        </div>
      </div>
    </div>

    <div class="card">
      <div class="head"><b>Người chơi</b><small id="roomShow">room: —</small></div>
      <div class="body">
        <div class="playersList" id="playersList"></div>
      </div>
    </div>

    <div class="card">
      <div class="head"><b>Event feed</b><small>mới nhất ở trên</small></div>
      <div class="body">
        <div class="feed" id="feed"></div>
      </div>
    </div>
  </aside>
</main>

<div id="toasts"></div>

<div class="modal" id="qModal">
  <div class="panel">
    <div class="mhead">
      <b>Chướng ngại vật • Quiz</b>
      <small id="qMeta" style="color:var(--muted)"></small>
    </div>
    <div class="mbody">
      <div id="qPrompt" style="font-size:16px; line-height:1.4"></div>
      <div class="bar"><div id="qBar"></div></div>
      <div class="choiceGrid" id="qChoices"></div>
      <div class="sub">Chọn đáp án bằng click hoặc phím <span class="kbd">1</span>…<span class="kbd">4</span>.</div>
    </div>
  </div>
</div>

<div class="modal" id="endModal">
  <div class="panel">
    <div class="mhead">
      <b>Kết thúc trận</b>
      <small id="endSmall" style="color:var(--muted)"></small>
    </div>
    <div class="mbody">
      <div class="winTitle" id="endTitle">—</div>
      <div class="sub" id="endDesc"></div>
      <div class="btnrow" style="margin-top:14px;">
        <button class="primary" onclick="location.reload()">Chơi lại</button>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  const WS_URL = (location.protocol === "https:" ? "wss://" : "ws://") + location.host + "/ws";
  document.getElementById("wsShow").textContent = WS_URL;

  const T_FLOOR = 0, T_WALL = 1, T_QUIZ = 2;

  const cv = document.getElementById("cv");
  const ctx = cv.getContext("2d");
  const mini = document.getElementById("mini");
  const mctx = mini.getContext("2d");

  let ws = null;
  let myId = null;
  let roomId = null;

  let mapW=0, mapH=0;
  let grid=null;
  let mapRev=0;
  let starts = {};
  let treasure = null;

  // state
  let phase = "—";
  let carrier = null;
  let players = {};  // pid -> {pos, ...}
  let names = {};    // pid -> name (from start if available)
  let renderPos = {}; // pid -> {x,y} float for smooth

  // map update highlight
  let changedCells = [];
  let changedUntil = 0;

  // question
  let activeQ = null;
  let qEndsAt = 0;
  let qAnim = null;

  const feedEl = document.getElementById("feed");

  function escapeHtml(s){
    return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
  }

  function setConn(on){
    const dot = document.getElementById("connDot");
    const text = document.getElementById("connText");
    dot.classList.toggle("on", on);
    text.textContent = on ? "Connected" : "Disconnected";
  }

  function toast(title, detail="", kind=""){
    const box = document.createElement("div");
    box.className = "toast " + (kind || "");
    box.innerHTML = "<b>"+escapeHtml(title)+"</b>" + (detail?("<small>"+escapeHtml(detail)+"</small>"):"");
    document.getElementById("toasts").appendChild(box);
    setTimeout(()=> box.style.opacity="0.0", 2400);
    setTimeout(()=> box.remove(), 2900);
  }

  function feed(line){
    const item = document.createElement("div");
    item.className = "evt";
    item.textContent = line;
    feedEl.prepend(item);
    while(feedEl.children.length > 12) feedEl.removeChild(feedEl.lastChild);
  }

  function setTopStats(){
    document.getElementById("phaseText").textContent = phase || "—";
    document.getElementById("carrierText").textContent = carrier ? (carrier === myId ? "ME" : "OPP") : "—";
    document.getElementById("revText").textContent = String(mapRev || 0);
    document.getElementById("roomShow").textContent = "room: " + (roomId || "—");
  }

  function updatePlayersList(){
    const list = document.getElementById("playersList");
    list.innerHTML = "";
    const entries = Object.entries(players);
    if (entries.length === 0){
      list.innerHTML = "<div style='color:var(--muted);font-size:12px'>Chưa có dữ liệu người chơi.</div>";
      return;
    }
    for (const [pid, p] of entries){
      const item = document.createElement("div");
      item.className = "pitem";
      const left = document.createElement("div");
      left.className = "left";
      const nm = document.createElement("div");
      nm.className = "nm";
      nm.textContent = (names[pid] || pid);
      const badges = document.createElement("div");
      const b1 = document.createElement("span");
      b1.className = "badge " + (pid === myId ? "me" : "");
      b1.textContent = (pid === myId) ? "YOU" : "RIVAL";
      badges.appendChild(b1);
      if (p.has_treasure){
        const bt = document.createElement("span");
        bt.className = "badge t";
        bt.textContent = "TREASURE";
        badges.appendChild(bt);
      }
      if (p.locked){
        const bs = document.createElement("span");
        bs.className = "badge stun";
        bs.textContent = "LOCK";
        badges.appendChild(bs);
      }
      left.appendChild(nm);
      item.appendChild(left);
      item.appendChild(badges);
      list.appendChild(item);
    }
  }

  function connect(){
    if (ws && ws.readyState === WebSocket.OPEN) return;
    ws = new WebSocket(WS_URL);
    ws.onopen = () => {
      setConn(true);
      const name = document.getElementById("name").value || "Player";
      ws.send(JSON.stringify({type:"join", name}));
      // Move focus to game canvas so WASD/Arrow keys work immediately
      try { document.getElementById("name").blur(); } catch(e) {}
      try { cv.focus(); } catch(e) {}
      toast("Connected", "Đang chờ ghép cặp...", "good");
    };
    ws.onclose = () => {
      setConn(false);
      ws = null;
      toast("Disconnected", "Mất kết nối tới server", "warn");
    };
    ws.onerror = () => {
      toast("WebSocket error", "Kiểm tra server đang chạy và port đúng", "bad");
    };
    ws.onmessage = (ev) => {
      const msg = JSON.parse(ev.data);

      if (msg.type === "start"){
        myId = msg.player_id;
        roomId = msg.room_id;

        mapW = msg.map.w;
        mapH = msg.map.h;
        grid = msg.map.grid;
        treasure = msg.map.treasure;
        starts = msg.map.starts || {};
        mapRev = msg.map.rev || 0;

        // names from current players
        if (msg.state && msg.state.players){
          // No name in state; keep input name for self
          names[myId] = document.getElementById("name").value || "Player";
        }

        if (msg.state){
          phase = msg.state.phase;
          carrier = msg.state.carrier;
          players = msg.state.players || {};
          mapRev = msg.state.map_rev || mapRev;
        }

        for (const [pid, p] of Object.entries(players)){
          renderPos[pid] = {x: p.pos[0], y: p.pos[1]};
        }

        setTopStats();
        updatePlayersList();
        feed("Match started. Bạn = " + myId);
        toast("Match started", "Dùng WASD / mũi tên để di chuyển", "good");
      }
      else if (msg.type === "state"){
phase = msg.phase;
carrier = msg.carrier;
players = msg.players || {};
if (msg.map_rev !== undefined) mapRev = msg.map_rev;

// Update treasure from authoritative server state
if (msg.treasure) treasure = msg.treasure;

// Update names from server
for (const [pid, p] of Object.entries(players)){
  if (p.name) names[pid] = p.name;
}

// init render pos if missing
for (const [pid, p] of Object.entries(players)){
  if (!renderPos[pid]) renderPos[pid] = {x:p.pos[0], y:p.pos[1]};
}
setTopStats();
updatePlayersList();
      }
      else if (msg.type === "map_update"){
        if (!grid){
          grid = msg.grid;
          mapRev = msg.map_rev || mapRev;
          setTopStats();
          return;
        }
        // diff
        const diffs = [];
        for (let y=0; y<grid.length; y++){
          for (let x=0; x<grid[0].length; x++){
            if (grid[y][x] !== msg.grid[y][x]) diffs.push([x,y]);
          }
        }
        changedCells = diffs;
        changedUntil = performance.now() + 900;
        grid = msg.grid;
        mapRev = msg.map_rev || mapRev;
        setTopStats();
      }
      else if (msg.type === "event"){
        feed(msg.name + " • " + msg.by);
        if (msg.name === "OBSTACLES_SHIFTED"){
          toast("Obstacles shifted", "Mê cung đã thay đổi", "warn");
        } else if (msg.name === "TREASURE_PICKED"){
          toast("Treasure picked", "Chế độ RETURN bắt đầu", "good");
        } else if (msg.name === "TREASURE_STOLEN"){
          toast("Treasure stolen", "Carrier đã đổi!", "bad");
        }
      }
      else if (msg.type === "question"){
        showQuestion(msg);
      }
      else if (msg.type === "end"){
        showEnd(msg.winner);
      }
      else if (msg.type === "error"){
        toast("Error", msg.message || "Unknown error", "bad");
      }
    };
  }

  function disconnect(){
    if (ws) ws.close();
  }

  function sendDir(dir){
    if (!ws || ws.readyState !== WebSocket.OPEN) return;
    ws.send(JSON.stringify({type:"input", dir}));
  }

  // Keybinds: movement + answer 1-4
  window.addEventListener("keydown", (e) => {
    const k = e.key;
    const lk = k.toLowerCase();
    const isMove = (lk === "w" || lk === "a" || lk === "s" || lk === "d" || k === "ArrowUp" || k === "ArrowDown" || k === "ArrowLeft" || k === "ArrowRight");
    if (isMove) e.preventDefault();
    if (lk === "w" || k === "ArrowUp") sendDir("U");
    else if (lk === "s" || k === "ArrowDown") sendDir("D");
    else if (lk === "a" || k === "ArrowLeft") sendDir("L");
    else if (lk === "d" || k === "ArrowRight") sendDir("R");
    else if (activeQ && ["1","2","3","4"].includes(k)){
      chooseAnswer(parseInt(k,10) - 1);
    }
  }, {capture:true});

  document.getElementById("btnConnect").onclick = connect;
  document.getElementById("btnDisconnect").onclick = disconnect;

  // Rendering
  function fitCell(){
    if (!grid) return 20;
    const cw = cv.width / mapW;
    const ch = cv.height / mapH;
    return Math.floor(Math.max(10, Math.min(cw, ch)));
  }

  function drawTile(x,y,t,cell,tm){
    if (t === T_WALL){
      ctx.fillStyle = "rgba(19,26,47,.95)";
      ctx.fillRect(x*cell, y*cell, cell, cell);
      // subtle inner
      ctx.fillStyle = "rgba(255,255,255,.03)";
      ctx.fillRect(x*cell+1, y*cell+1, cell-2, cell-2);
    } else {
      // floor
      ctx.fillStyle = "rgba(245,245,255,.06)";
      ctx.fillRect(x*cell, y*cell, cell, cell);
      if (t === T_QUIZ){
        const pulse = 0.55 + 0.45*Math.sin(tm*0.006 + (x+y)*0.6);
        ctx.fillStyle = "rgba(255,204,0," + (0.12 + 0.20*pulse).toFixed(3) + ")";
        ctx.fillRect(x*cell+2, y*cell+2, cell-4, cell-4);
      }
    }
  }

  function drawTreasure(cell, tm){
    if (!treasure) return;
    const x = treasure[0]*cell + cell/2;
    const y = treasure[1]*cell + cell/2;
    const r = cell*0.22 + 1.5*Math.sin(tm*0.008);
    ctx.save();
    ctx.translate(x,y);
    ctx.fillStyle = "rgba(124,92,255,.95)";
    ctx.shadowColor = "rgba(124,92,255,.55)";
    ctx.shadowBlur = 14;
    // simple diamond
    ctx.beginPath();
    ctx.moveTo(0,-r);
    ctx.lineTo(r,0);
    ctx.lineTo(0,r);
    ctx.lineTo(-r,0);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }

  function drawChanged(cell, tm){
    if (!changedCells || changedCells.length===0) return;
    if (tm > changedUntil) { changedCells = []; return; }
    const alpha = 0.35 + 0.25*Math.sin(tm*0.02);
    ctx.fillStyle = "rgba(37,208,255,"+alpha.toFixed(3)+")";
    for (const [x,y] of changedCells){
      ctx.fillRect(x*cell+3, y*cell+3, cell-6, cell-6);
    }
  }

  function drawPlayers(cell, tm){
    for (const [pid, p] of Object.entries(players)){
      const tgtx = p.pos[0], tgty = p.pos[1];
      const rp = renderPos[pid] || {x:tgtx, y:tgty};
      // interpolate
      const s = 0.22;
      rp.x += (tgtx - rp.x) * s;
      rp.y += (tgty - rp.y) * s;
      renderPos[pid] = rp;

      const cx = (rp.x * cell) + cell/2;
      const cy = (rp.y * cell) + cell/2;
      const isMe = (pid === myId);
      const isCarrier = p.has_treasure;

      const base = isMe ? "35,201,168" : "255,77,109";
      ctx.save();
      ctx.shadowColor = "rgba("+base+","+(isMe?0.45:0.30)+")";
      ctx.shadowBlur = isMe ? 18 : 14;
      ctx.fillStyle = "rgba("+base+",0.95)";
      ctx.beginPath();
      ctx.arc(cx, cy, cell/2 - 3, 0, Math.PI*2);
      ctx.fill();

      // inner eye / highlight
      ctx.fillStyle = "rgba(255,255,255,.18)";
      ctx.beginPath();
      ctx.arc(cx - cell*0.12, cy - cell*0.12, cell*0.10, 0, Math.PI*2);
      ctx.fill();

      if (isCarrier){
        ctx.fillStyle = "rgba(124,92,255,.95)";
        ctx.shadowColor = "rgba(124,92,255,.55)";
        ctx.shadowBlur = 16;
        ctx.fillRect(cx - 4, cy - 4, 8, 8);
      }
      ctx.restore();
    }
  }

  function drawMini(){
    if (!grid) return;
    const w = mini.width, h = mini.height;
    const sx = w / mapW, sy = h / mapH;
    mctx.clearRect(0,0,w,h);
    for (let y=0; y<mapH; y++){
      for (let x=0; x<mapW; x++){
        const t = grid[y][x];
        if (t === T_WALL) mctx.fillStyle = "rgba(19,26,47,.95)";
        else if (t === T_QUIZ) mctx.fillStyle = "rgba(255,204,0,.85)";
        else mctx.fillStyle = "rgba(245,245,255,.10)";
        mctx.fillRect(x*sx, y*sy, sx, sy);
      }
    }
    if (treasure){
      mctx.fillStyle = "rgba(124,92,255,.95)";
      mctx.fillRect(treasure[0]*sx, treasure[1]*sy, sx, sy);
    }
    for (const [pid, p] of Object.entries(players)){
      mctx.fillStyle = (pid === myId) ? "rgba(35,201,168,.95)" : "rgba(255,77,109,.95)";
      mctx.fillRect(p.pos[0]*sx, p.pos[1]*sy, sx, sy);
    }
  }

  function render(tm){
    ctx.clearRect(0,0,cv.width,cv.height);
    if (!grid){
      ctx.fillStyle = "rgba(234,240,255,.65)";
      ctx.font = "16px system-ui";
      ctx.fillText("Nhấn Connect để bắt đầu.", 18, 28);
      requestAnimationFrame(render);
      return;
    }

    const cell = fitCell();

    // Center the map within canvas (letterbox)
    const mapPxW = mapW * cell;
    const mapPxH = mapH * cell;
    const offX = Math.floor((cv.width - mapPxW)/2);
    const offY = Math.floor((cv.height - mapPxH)/2);
    ctx.save();
    ctx.translate(offX, offY);

    // background grid subtle
    ctx.fillStyle = "rgba(0,0,0,.18)";
    ctx.fillRect(0,0,mapPxW,mapPxH);

    for (let y=0; y<mapH; y++){
      for (let x=0; x<mapW; x++){
        drawTile(x,y,grid[y][x],cell,tm);
      }
    }
    drawChanged(cell, tm);
    drawTreasure(cell, tm);
    drawPlayers(cell, tm);

    // start markers
    for (const [pid, pos] of Object.entries(starts)){
      ctx.strokeStyle = "rgba(234,240,255,.18)";
      ctx.lineWidth = 2;
      ctx.strokeRect(pos[0]*cell+2, pos[1]*cell+2, cell-4, cell-4);
    }

    ctx.restore();

    drawMini();
    updateQuestionBar();
    requestAnimationFrame(render);
  }
  requestAnimationFrame(render);

  // Question UI
  const qModal = document.getElementById("qModal");
  const qPrompt = document.getElementById("qPrompt");
  const qMeta = document.getElementById("qMeta");
  const qChoices = document.getElementById("qChoices");
  const qBar = document.getElementById("qBar");

  function showQuestion(q){
    activeQ = q;
    qModal.classList.add("on");
    qPrompt.textContent = q.prompt || "";
    if (q.meta){
      qMeta.textContent = "category=" + q.meta.category + ", difficulty=" + q.meta.difficulty;
    } else {
      qMeta.textContent = "";
    }
    qChoices.innerHTML = "";
    const choices = q.choices || [];
    for (let i=0; i<choices.length; i++){
      const div = document.createElement("div");
      div.className = "choice";
      div.textContent = (i+1) + ". " + choices[i];
      div.onclick = () => chooseAnswer(i);
      qChoices.appendChild(div);
    }
    // purely UX countdown (server does not enforce)
    qEndsAt = performance.now() + 12000;
    updateQuestionBar(true);
    toast("Quiz!", "Trả lời để vượt chướng ngại vật", "warn");
  }

  function chooseAnswer(idx){
    if (!activeQ) return;
    if (ws && ws.readyState === WebSocket.OPEN){
      ws.send(JSON.stringify({type:"answer", qid: activeQ.qid, choice: idx}));
    }
    qModal.classList.remove("on");
    activeQ = null;
  }

  function updateQuestionBar(force=false){
    if (!activeQ){
      qBar.style.transform = "scaleX(1)";
      return;
    }
    const now = performance.now();
    const remain = Math.max(0, qEndsAt - now);
    const t = remain / 12000;
    qBar.style.transform = "scaleX(" + t.toFixed(3) + ")";
    if (remain <= 0){
      // auto-close (optional)
      qModal.classList.remove("on");
      activeQ = null;
    }
  }

  // End modal
  const endModal = document.getElementById("endModal");
  const endTitle = document.getElementById("endTitle");
  const endDesc = document.getElementById("endDesc");
  const endSmall = document.getElementById("endSmall");

  function showEnd(winner){
    endModal.classList.add("on");
    endSmall.textContent = "winner: " + winner;
    if (winner === myId){
      endTitle.textContent = "Bạn thắng!";
      endDesc.textContent = "Bạn đã đem kho báu về điểm xuất phát. Chúc mừng.";
      toast("Victory", "Bạn thắng trận", "good");
    } else if (winner === "disconnect"){
      endTitle.textContent = "Kết thúc";
      endDesc.textContent = "Đối thủ đã rời trận.";
      toast("Match ended", "Đối thủ disconnect", "warn");
    } else {
      endTitle.textContent = "Bạn thua!";
      endDesc.textContent = "Đối thủ đã đem kho báu về điểm xuất phát.";
      toast("Defeat", "Thử lại lần nữa", "bad");
    }
  }

})();
</script>
</body>
</html>
